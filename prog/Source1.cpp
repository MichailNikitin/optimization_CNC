/*Практикум для магистров  Расчет 
2-х ступенчатого цикла круглого шлифования с радиальной подачей
Расчет выполнен способом №1 */
#include <cmath>
#include <iostream>
#include <cstdlib>;
#include <iomanip>
#include <fstream> //библиотека потокового ввода/вывода
using namespace std;
#define M_PI       3.14159265358979323846
double etgb, dk, b, nd, sigma, stzat, k3, k4, tf_sum_i_1;
double dz_max, tdz, dz_min, dd_max, dd_min, td, podatl, sf, tp_sum, tf_sum;
double rzag_max, a, x, y, c, r, fi, time_cicle, time_ob, sp[2], nsum;
double pripd_pak[2], pripd_max, pripd_min, dpak[2], с1_tf_ob, ddo;
double ypr_def, py, ddet_max, ddet_min, rdet_max, rdet_min, rb_det, c2_tf_ob;
double tf_ob, tp_ob[2], vk;
int  i, zmax, z, j;
char data_grafik[20]; // строка из 20 символов для имени файла для записи данных графика
int main() {
	//================================================
	setlocale(LC_ALL, "Rus");
	cout << "ввод данных по заготовке и детали" << endl;
	dz_max = 50.3;  // # Максимальный диаметр заготовки, мм
	tdz = 0.039;// #допуск диаметра заготовки, мм
	dz_min = dz_max - tdz; // # минимальный диаметр заготовки, мм
	dd_max = 50.00; // # Максимальный диаметр детали, мм
	rzag_max = dz_max / 2; //максимальный радиус заготовки,мм
	td = 0.016;  // # допуск диаметра детали, мм
	dd_min = dd_max - td;  // # минимальный диаметр детали, мм
	pripd_max = dz_max - 0.5 * (dd_max + dd_min); // # припуск на диаметр максимальный, мм
	pripd_min = dz_min - 0.5 * (dd_max + dd_min); // # припуск на диаметр минимальный, мм
	etgb = 9.47;  // ei*tg betta см.формулу
	b = 10.;  //  длина шлифуемой поверхностиб мм
	sigma = 180.;  //интенсивность напряжений, кг / мм2
		//====================================================
	cout << "ввод исходных данных по шлифовальному кругу" << endl;
	stzat = 0.01;    // #степень затупления круга
	dk = 300;  // диметр круга, мм
	cout << "dk=" << dk << "	stzat=" << stzat << endl;
	// ====================================================
	cout << "ввод исходных данных по станку" << endl;
	podatl = 0.003;  //  Податливость технологической системы, мм / кг
	vk = 30000. * 60.;  //  # окружная скорость вращения круга, мм / мин
	nd = 300.;  // частота вращения детали, об / мин
	cout << "nd=" << nd << "	vk=" << vk << endl;
	// ====================================================
	cout << "ввод исходных данных по циклу" << endl;
	time_ob = 1 / nd; // # время одного оборота заготовки, мин
	zmax = 2;  // # количество ступеней цикла
	sp[0] = 3.0; // # программная минутная подача на первой ступени цикла, мм / мин
	sp[1] = 0.1; // # программная минутная подача на второй ступени цикла, мм / мин 
	tp_ob[0] = sp[0] / nd;     //  программная на оборот первой ступени цикла, мм / об 
	tp_ob[1] = sp[1] / nd;  //  программная на оборот второй ступени цикла, мм / об 
	// ====================================================
	cout << "ввод исходных данных по ПАКу" << endl;
	pripd_pak[0] = 0.85 * pripd_max;  // # припуск на диаметр на первой ступени цикла, мм
	pripd_pak[1] = pripd_max - pripd_pak[0];  // # припуск на диаметр на второй ступени цикла, мм
	dpak[0] = dz_max - pripd_pak[0]; // # диаметр ПАК переключения подачи после первой ступени
	dpak[1] = 0.5 * (dd_max + dd_min);  // # диаметр ПАК переключения подачи после второй ступени(конец цикла)
	cout << "	nd=" << nd << "		zmax=" << zmax << "		sp[0]=" << sp[0] << "	sp[1]=" << sp[1] << "	tp_ob[0]=" << tp_ob[0] << "		tp_ob[1]=" << tp_ob[1] << endl;
	cout << "pripd_max=" << pripd_max << "		pripd_pak[0]=" << pripd_pak[0] << "		pripd_pak[1]=" << pripd_pak[1] << endl;
	cout << "		dpak[0]=" << dpak[0] << "		dpak[1]=" << dpak[1] << endl;
	//cout << "Проверка припусков" << "pripd_pak[0]+pripd_pak[1]=" << pripd_pak[0] + pripd_pak[1]; << "dz_max-dpak[1]=" << dz_max - dpak[1];) << endl
	system("pause");
	//====================================================
	cout << "расчет коэффициентов" << endl;
	k3 = M_PI * dz_max * b * sigma * etgb * nd / vk;  //первый коф-т в формуле силы Ру через tф
	k4 = stzat * sigma * b * sqrt(dz_max * dk / (dz_max + dk)) / 3; //второй коф-т в формуле силы Ру через tф
	с1_tf_ob = 0.5 * podatl * k4 / (1 + k3 * podatl);  //  коэф в формуле tf_ob
	cout << "		k3=" << k3 << "		k4=" << k4 << "		с1_tf_ob =" << с1_tf_ob << endl;
	cout << "Закончен ввод данных" << endl;
	//===========================
//ввод данных для формирования графика - запись данных графика в файл
	string data_grafik = "datagrafiks_.xls"; //имя файла где будут записаны данные для графиков
	ofstream f; //объявляем поток записи данных для графиков в файл
	f.open(data_grafik); // открываем файл
	//записываем наименование шапок столбцов таблиц графика Excel
	f.width(20); f << "z" << ";"; f.width(20); f << "nsum" << ";";	f.width(20); f << "sp[z]" << ";";
	f.width(20); f << "tp_ob[z]" << ";"; f.width(20); f << "tp_sum" << ";"; f.width(20); f << "tf_ob" << ";";
	f.width(20); f << "tf_sum" << ";"; f.width(20); f << "sf" << ";"; f.width(20); 	f << "py" << ";";
	f.width(20); f << "ypr_def" << ";"; f.width(20); f << "ddo" << ";"; f.width(20); f << "dpak[z]" << ";";
	f.width(20); f << "time_cicle" << ";"; f.width(20); f << "tf_sum_i_1" << endl;
	// ====================================================
							// Закончен ввод данных
	//# ++++++++++=====Начало расчета цикла==+++++++++++++++++++++++++++++++++++++++++++++++++
	//#########################################################################################
	cout << "METKA1+++++++++=====Начало расчета цикла==+++++++++++++++" << endl;
	cout << "Задаем стартовые значения переменным" << endl;
	ddo = dz_max; //# ddo-текущий диаметр детали контролируемый ПАКом  в процессе съема металла
	nsum = 0;   // # обнуляем номер оборота детали 
	time_cicle = 0.;// # обнуляем время цикла шлифования, мин
	py = 0.;
	ypr_def = 0.;
	sf = 0.; //  Обнуляем фактическую минутную подачу
	tf_ob = 0.;  // Обнуляем фактическую подачу за оборот
	z = 0; // первая ступень цикла z = 0 имеет индекс 0
	tp_sum = 0.; //  Обнуляем суммарную программную подачу при nsum=0, мм
	tf_sum = 0.; //  Обнуляем суммарную фактическую подачу при nsum=0, мм
	tf_sum_i_1 = 0.; //Обнуляем значение накопленной фактической подачина i-1 обороте
		//записываем данные для графика
	f.width(20); f << z << ";"; 	f.width(20); f << nsum << ";"; f.width(20); f << sp[z] << ";";
	f.width(20);	f << tp_ob[z] << ";";	f.width(20);	f << tp_sum << ";";
	f.width(20);	f << tf_ob << ";";	f.width(20);	f << tf_sum << ";";
	f.width(20);	f << sf << ";";	f.width(20);	f << py << ";";
	f.width(20);	f << ypr_def << ";";	f.width(20);	f << ddo << ";";
	f.width(20);	f << dpak[z] << ";";	f.width(20);	f << time_cicle << ";";
	f.width(20);	f << tf_sum_i_1 << endl;
	cout << "Начинаем расчет цикла шлифования ===========%%%%%%%%%%%%%%%%%%%%%%%%%" << endl;
	cout << fixed << setprecision(5);
	//# Начало цикла по текущему номеру ступени цикла 0<=z<=zmax-1            ++++++++++++++++++ +			
	for (z = 0; z < zmax; z++) {
		while (ddo > dpak[z]) // # Начало цикла по текущему диаметру ddo по ступеням dpak++++++++++++ +
		{
			nsum = nsum + 1;
			tp_sum = tp_sum + tp_ob[z];//считаем текущее значение накопленной программной подачи на каждом радиусе
			c2_tf_ob = (tp_ob[z] + py * podatl) / (1 + k3 * podatl); //# коэф в формуле tf_ob
			x = -с1_tf_ob + sqrt(с1_tf_ob * с1_tf_ob + c2_tf_ob);
			tf_ob = x * x;//считаем текущее значение  фактической подачи
			tf_sum = tf_sum + tf_ob;  // считаем текущее значение накопленной фактической подачина i обороте
			tf_sum_i_1 = tf_sum - tf_ob;  // считаем  предшествующую накопленную фактическую подачу на i-1 обороте		
			sf = tf_ob * nd; //вычисляем фактическую минутную подачу
			py = k3 * tf_ob + k4 * sqrt(tf_ob);  // радиальная сила резания, кг
			ypr_def = podatl * py;  // упругая деформация ТС, мм
			ddo = ddo - 2 * tf_ob;  //расчет текущего значения диаметра
			time_cicle = nsum * time_ob;    // # считаем время цикла шлифования, мин
			cout << "METKA 1" << "		z=" << z << "		nsum=" << nsum << "		tp_ob[z]=" << tp_ob[z] << endl;
			cout << "tf_ob=" << tf_ob << "		sf=" << sf << "		py=" << py << "		ypr_def=" << ypr_def << endl;
			cout << "tp_sum=" << tp_sum << "		tf_sum=" << tf_sum << endl;
			cout << "ddo=" << ddo << "		dpak[z]=" << dpak[z] << "		time_cicle=" << time_cicle << endl;
			//записываем данные для графика
			f.width(20); f << z << ";"; 	f.width(20); f << nsum << ";"; f.width(20); f << sp[z] << ";";
			f.width(20); f << tp_ob[z] << ";";	f.width(20);	f << tp_sum << ";";
			f.width(20); f << tf_ob << ";";	f.width(20); f << tf_sum << ";";
			f.width(20); f << sf << ";"; f.width(20); f << py << ";";
			f.width(20); f << ypr_def << ";"; f.width(20); 	f << ddo << ";";
			f.width(20); f << dpak[z] << ";"; f.width(20); f << time_cicle << ";";
			f.width(20); f << tf_sum_i_1 << endl;
			//конец записи данных для графика
		} // КОНЕЦ ЦИКЛА while ПО ddo++++++++++++++++++++++++++++++++++++++++++++++
		cout << "КОНЕЦ ЦИКЛА while ПО ddo" << endl;
	} // конец цикла for по z    ++++++++++++++++++++++++++++++++++++++++++++++++++++++
	cout << "КОНЕЦ ЦИКЛА for по z" << endl;
	//закрываем файл с данными для графика
	f.close(); // закрываем файл
	system("pause");
	return 0;
}//++++++++++++++++++КОНЕЦ main

